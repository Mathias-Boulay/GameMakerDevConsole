<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize
Instance_to_track = "";
Instance_name = ""; //Converted

//Serves as pre-allocation of memory.
for(i=0;i&lt;10;i++){
    Variables[i,0] = ""; //Serve for the name
    Variables[i,1] = ""; //Serve for the value
    //Converted values:
    VariablesName[i] = "";
    VariablesValue[i] = "";
    }

xx = device_mouse_x_to_gui(0);
yy = device_mouse_y_to_gui(0);

mx = 0;
my = 0;

hover = false;
focus = false;

box_left = 0;
box_right = 0;
box_top = 0;
box_bottom = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update position and bounding boxes

//Mouse sync:
if device_mouse_x_to_gui(0) &gt; box_left &amp;&amp; device_mouse_x_to_gui(0) &lt; box_right &amp;&amp; device_mouse_y_to_gui(0) &gt; box_top &amp;&amp; device_mouse_y_to_gui(0) &lt; box_bottom{
    hover = true;
    if device_mouse_check_button_pressed(0,mb_left){
        focus = true;
        mx = device_mouse_x_to_gui(0) - xx;
        my = device_mouse_y_to_gui(0) - yy;
        }
    }
else{
    if device_mouse_x_to_gui(0) &gt; Instance_to_track.bbox_left &amp;&amp; device_mouse_x_to_gui(0) &lt; Instance_to_track.bbox_right &amp;&amp; device_mouse_y_to_gui(0) &gt; Instance_to_track.bbox_top &amp;&amp; device_mouse_y_to_gui(0) &lt; Instance_to_track.bbox_bottom{
        hover = true;
        }
    else{
        hover = false;
        }
    }

//Follows the mouse cursor 
if (focus){
    hover = true;
    xx = -mx + device_mouse_x_to_gui(0);
    yy = -my + device_mouse_y_to_gui(0);
    
    xx = clamp(xx,((__spse_string_size(Instance_name)/2)+2),display_get_gui_width()-((__spse_string_size(Instance_name)/2)+2));
    yy = clamp(yy,7,display_get_gui_height()-7);
    }
    
    
//bounding boxes:
box_left = xx - ((__spse_string_size(Instance_name)/2)+2);
box_right = xx + ((__spse_string_size(Instance_name)/2)+2);
box_top = yy - 7;
box_bottom = yy + 7;

    
    
//UPDATE VARIABLES:
if instance_exists(Instance_to_track){
    //First step: Flush variables that don't exist anymore:
    for(i=0;i&lt;array_height_2d(Variables)-1;i++){
        if !variable_instance_exists(Instance_to_track,Variables[i,0]){
            //Flush the values:
            Variables[i,0] = "";
            Variables[i,1] = "";
            VariablesName[i] = "";
            VariablesValue[i] = "";
            }
        }
        
    //Second step: Remove empty intermediate spaces:
    for(i=1;i&lt;array_height_2d(Variables)-1;i++){
        for(j=0;j&gt;-1;j++){
            if (Variables[i-j,0] != "") &amp;&amp; (Variables[i-1-j,0] = ""){
                //Transfer the variable name 
                Variables[i-1-j,0] = Variables[i-j,0];
                VariablesName[i-j-1] = VariablesName[i-j];
                //Flush the rest, will be updated.
                Variables[i-j,0] = "";
                Variables[i-j,1] = "";
                VariablesName[i-j] = "";
                VariablesValue[i-j] = "";
                
                }
            else{
                break;
                i+=j; //Jump through the void created by the for loop.
                }
            }
        
        }
        
    //Step 3: Update existing variables
    for(i=1;i&lt;array_height_2d(Variables)-1;i++){
        if Variables[i,0] != ""{
            //Just check if there is the converted name.
            if VariablesName[i] = ""{
                VariablesName[i] = __spse_text_converter_to_sprite_index(Variables[i,0]);
                }
            if !is_array(variable_instance_get(Instance_to_track,Variables[i,0])){
                Variables[i,1] = variable_instance_get(Instance_to_track,Variables[i,0]);
                VariablesValue[i] = __spse_text_converter_to_sprite_index(string(Variables[i,1]));
                }
            }
        else{
            break;
            }
        }
        
    }
else{
    //It means the instance we're looking for is missing.
    if (object_main_console.Auto_destroy_instance_follower){
        instance_destroy();
        }
    }
    


    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///We remove the focus.
focus = false;
mx = 0;
my = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Apply some properties to other instances:
if object_main_console.Force_debug_instances_visible{
    Instance_to_track.visible = true;
    }
if object_main_console.Force_all_instances_visible{
    with(all){
        visible = true;
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw itself.
//I want a semi white rounded rectangle:

//Backup drawing settings to restore them.
draw_color = draw_get_colour();
draw_alpha = draw_get_alpha();
draw_shader = shader_current();

//Set drawing conditions:
shader_reset();
draw_set_alpha(0.4);
if (hover){
    draw_set_color(c_lime);
    }
else{
    draw_set_color(c_white);
    }

draw_roundrect(box_left,box_top,box_right,box_bottom,false);


//Variables:
for(i=0;i&lt;array_height_2d(Variables);i++){
    if Variables[i,0] != ""{
        draw_roundrect(xx - ((__spse_string_size(Variables[i,0])/2)+(__spse_string_size(string(Variables[i,1]))/2)), yy + ((i+1)*10) -5, xx + (__spse_string_size(Variables[i,0])/2) +(__spse_string_size(string(Variables[i,1]))/2),yy + ((i+1)*10) +5,false);
        }
    }

draw_set_alpha(1);


//Time to restore:
if (hover){ //This test avoids breakling the draw pipeline if the color is already the one we want.
    draw_set_color(c_white);
    }

//Some text:
__spse_draw_text_sprite_font(box_left+6,yy,Instance_name);

//Time for variables to shine !
for(i=0;i&lt;array_height_2d(Variables);i++){
    if Variables[i,0] != ""{
        __spse_draw_text_sprite_font(xx - __spse_string_size(VariablesName[i])/2, yy + ((i+1)*10), VariablesName[i]);
        __spse_draw_text_sprite_font(xx + __spse_string_size(VariablesValue[i])/2, yy + ((i+1)*10), VariablesValue[i]);
        }
    }












//Reset to the usual state:
draw_set_color(draw_color);
shader_set(draw_shader);
draw_set_alpha(draw_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the overlay if the option is set to true

//Backup drawing settings to restore them.
draw_color = draw_get_colour();
draw_alpha = draw_get_alpha();
draw_shader = shader_current();


draw_set_alpha(0.4);
shader_reset();
if (hover){
    draw_set_color(c_lime);
    }
else{
    draw_set_color(c_white);
    }


if instance_exists(Instance_to_track){
    if (object_main_console.Overlay_drawing){
        draw_rectangle(
                        Instance_to_track.bbox_left,
                        Instance_to_track.bbox_top,
                        Instance_to_track.bbox_right,
                        Instance_to_track.bbox_bottom,
                        false
                        );
        }
    }
    
    
    
//Reset to the usual state:
draw_set_color(draw_color);
shader_set(draw_shader);
draw_set_alpha(draw_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
